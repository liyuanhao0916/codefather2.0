# 谷粒商城

## 基础篇

### 准备工作

#### 安装

- 软件

  - mysql

  - redis

- 插件

  ```
  vscode
  
  Auto Close Tag  
  Auto Rename Tag 
  Chinese 
  ESlint 
  HTML CSS Support
  HTML Snippets
  JavaScript (ES6) code snippets
  Live Server
  open in brower
  Vetur
  
  idea
  lombok、mybatisx
  ```

- git

  ```
  ## 配置用户名
  git config --global user.name "username"  //(名字，随意写)
  
  ## 配置邮箱
  git config --global user.email "55333@qq.com" // 注册账号时使用的邮箱
  
  ## 配置ssh免密登录
  ssh-keygen -t rsa -C "55333@qq.com"
  
  三次回车后生成了密钥，也可以查看密钥
  cat ~/.ssh/id_rsa.pub
  
  
  浏览器登录码云后，个人头像上点设置、然后点ssh公钥、随便填个标题，然后赋值
  ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6MWhGXSKdRxr1mGPZysDrcwABMTrxc8Va2IWZyIMMRHH9Qn/wy3PN2I9144UUqg65W0CDE/thxbOdn78MygFFsIG4j0wdT9sdjmSfzQikLHFsJ02yr58V6J2zwXcW9AhIlaGr+XIlGKDUy5mXb4OF+6UMXM6HKF7rY9FYh9wL6bun9f1jV4Ydlxftb/xtV8oQXXNJbI6OoqkogPKBYcNdWzMbjJdmbq2bSQugGaPVnHEqAD74Qgkw1G7SIDTXnY55gBlFPVzjLWUu74OWFCx4pFHH6LRZOCLlMaJ9haTwT2DB/sFzOG/Js+cEExx/arJ2rvvdmTMwlv/T+6xhrMS3 894548575@qq.com
  
  ## 测试
  ssh -T git@gitee.com
  
  ## 测试成功
  Hi unique_perfect! You've successfully authenticated, but GITEE.COM does not provide shell access.
  ```

#### 创建工程

- 聚合工程gulimall

- springboot创建以下模块

  - 每个模块导入web和openFeign
  - 包名com.botuer.gulimall.order…

  ```
  商品服务gulimall-product
  存储服务gulimall-ware
  订单服务gulimall-order
  优惠券服务gulimall-coupon
  用户服务gulimall-member
  ```

- clone人人开源，聚合到gulimall

- 忽略版本控制

  ```
  target/
  pom.xml.tag
  pom.xml.releaseBackup
  pom.xml.versionsBackup
  pom.xml.next
  release.properties
  dependency-reduced-pom.xml
  buildNumber.properties
  .mvn/timing.properties
  .mvn/wrapper/maven-wrapper.jar
  
  **/mvnw
  **/mvnw.cmd
  
  **/.mvn
  **/target
  
  .idea
  
  
  **/.gitignore
  
  **/README.md
  ```
  
  - 不起作用
  
    ```shell
    第一步：cd 到项目目录
    第二步：git rm -r --cached .
    第三步：git add .
    第四步：git commit -m 'update .gitignore'
    ```


##### 测试 --- 前后端联调

- 后端启动renren-fast测试

  - 修改配置文件 --- 数据库配置信息

  - 报错类型为【找不到类型io.renren.modules.sys.entity.SysUserEntity的变量 user】

    > 升级lombok版本

    ```
    Node.js v14.18.2 to /usr/local/bin/node
    	•	npm v6.14.15 to /usr/local/bin/npm
    ```

- 前端用VSCode打开renren-fast-vue

  ```sh
  ## 设置node仓库。提高下载速度
  npm config set registry http://registry.npm.taobao.org/
  ## 安装插件
  npm install
  ## 启动项目
  npm run dev
  ```

  - 注意node版本为14
  - 登录账号密码admin

  - 报错【chromedriver@2.27.2 install: `node install.js`】

    ```sh
    npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver
    ```

    还是不行，手动安装

    mac：https://cdn.npmmirror.com/binaries/chromedriver/2.27/chromedriver_mac64.zip

    win：https://npm.taobao.org/mirrors/chromedriver/2.27/chromedriver_win32.zip

    ```sh
    npm install chromedriver --chromedriver_filepath=你的下载路径\文件名
    ```

  - 报错【missing script: serve】

    - **查看package.json文件scripts-start的配置**

      ```json
      {
        "name": "renren-fast-vue",
        "version": "1.2.2",
        "description": "renren-fast-vue基于vue、element-ui构建开发，实现renren-fast后台管理前端功能，提供一套更优的前端解决方案。",
        "author": "daxiong.yang <daxiong.yang@qq.com>",
        "private": true,
        "scripts": {
          "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
          "start": "npm run dev",
          "unit": "jest --config test/unit/jest.conf.js --coverage",
          "e2e": "node test/e2e/runner.js",
          "test": "npm run unit && npm run e2e",
          "lint": "eslint --ext .js,.vue src test/unit/specs test/e2e/specs",
          "build": "gulp"
        },
        ...
        ...
      }
      ```

#### 代码生成器

- 修改application.yml配置文件 --- 数据库配置

- 修改generator.propertied

  ```properties
  mainPath=com.botuer
  package=com.botuer.gulimall
  moduleName=product
  tablePrefix=pms_
  
  author=li
  email=sun@gmail.com
  
  #......
  ```

- 创建gulimall-common工程，并添加到各个工程的依赖中

- gulimall-common的依赖

  ```xml
  <!-- mybatis-plus -->
  <dependency>
      <groupId>com.baomidou</groupId>
      <artifactId>mybatis-plus-boot-starter</artifactId>
      <version>3.4.2</version>
  </dependency>
  <!-- mysql -->
  <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <scope>runtime</scope>
  </dependency>
  <!-- lombok -->
  <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
  </dependency>
  <!-- httpcore -->
  <dependency>
      <groupId>org.apache.httpcomponents</groupId>
      <artifactId>httpcore</artifactId>
      <version>4.4.13</version>
  </dependency>
  <!-- commons-lang -->
  <dependency>
      <groupId>commons-lang</groupId>
      <artifactId>commons-lang</artifactId>
      <version>2.6</version>
  </dependency>
  <!-- servlet -->
  <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>4.0.1</version>
      <scope>provided</scope>
  </dependency>
  ```

- gulimall-common的类

  - utils --- Query、PageUtils、R、Constant
    - 把Constant中的云服务商注释掉
  - xss --- HTMLFilter、SQLFilter
  - exception --- RRException

- 各个工程的controller

  - 删除@RequiresPermissions

##### 测试 --- CRUD

- 创建application.yml

  ```yml
  spring:
    datasource:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://42.193.100.99/gulimall_pms?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
      username: root
      password: root
  
  
  ## MapperScan
  ## sql映射文件位置
  ## 主键子增
  mybatis-plus:
    mapper-locations: classpath:/mapper/**/*.xml
    global-config:
      db-config:
        id-type: auto
  ```

- 启动类加注解@MapperScan("dao的包名")

- 测试

  ```java
  @SpringBootTest
  class GulimallProductApplicationTests {
  
  	@Autowired
  	BrandService brandService;
  
  	@Test
  	public void contextLoads() {
  		BrandEntity brandEntity = new BrandEntity();
  		brandEntity.setDescript("hello");
  		brandEntity.setName("华为");
  		brandService.save(brandEntity);
  		System.out.println("保存成功");
  	}
  
  }
  ```

  - 报错【org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-jupiter' failed 】

    > maven -- clean、install

    还是不行就只剩下代码和pom文件，删除其他，清除git缓存，重新构建

- 其他工程

  - 改端口号

  - 加application.yml

  - 加注解@MapperScan

  - 测试

    ```
    http://localhost:8000/coupon/coupon/list
    http://localhost:9000/member/growthchangehistory/list
    http://localhost:10000/order/order/list
    http://localhost:11000/ware/wareinfo/list
    http://localhost:12000/product/brand/list
    ```


#### Nacos

##### 注册中心

- 安装

- common中倒入依赖

  ```xml
  <properties>
      <spring-boot.version>2.3.7.RELEASE</spring-boot.version>
      <spring-cloud-alibaba.version>2.2.5.RELEASE</spring-cloud-alibaba.version>
      <spring-cloud.version>Hoxton.SR9</spring-cloud.version>
  </properties>
  
  <dependencies>
  		<!-- nacos注册发现 -->
    	<dependency>
    	    <groupId>com.alibaba.cloud</groupId>
    	    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    	</dependency>
  </dependencies>
  
  <dependencyManagement>
     	<dependencies>
     	    <dependency>
     	        <groupId>com.alibaba.cloud</groupId>
     	        <artifactId>spring-cloud-alibaba-dependencies</artifactId>
     	        <version>${spring-cloud-alibaba.version}</version>
     	        <type>pom</type>
     	        <scope>import</scope>
     	    </dependency>
    	</dependencies>
  </dependencyManagement>
  ```

- 注册 --- 配置application.yml 、**启动类添加注解 @EnableDiscoveryClient**

  ```yaml
  spring:
    application:
      name: gulimall-coupon
    cloud:
      nacos:
        discovery:
          server-addr: 192.168.10.103:8848
  ```

##### 配置中心

- 因为要做集群，为减少配置文件的配置，将公用的放到配置中心

- commen中引入依赖

  ```xml
  <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
  ```

- 具体的服务中创建配置文件bootstrap.yml

  - 读到配置中心地址 ---> 根据 **`服务名-开发环境.后缀名`** ，读取对应的配置文件
  -  **`服务名.后缀名`** 作为公用的配置，任何开发环境都可读取到
  - 顺序：bootstrap.yml --  **`服务名-开发环境.后缀名`**  --  **`服务名.后缀名`**  -- application.properties -- application.yml

  ```yml
  spring:
    application:
      name: gulimall-coupon ## 服务名称
    profiles:
      active: dev #开发环境，这里是dev 
    cloud:
      nacos:
        server-addr: localhost:8848 ## Nacos地址
        config:
          file-extension: yaml ## 文件后缀名
  ```

- 配置热更新

  - 方式一：@value所在的类加@RefreshScope，即**@value + @RefreshScope**
  - 方式二：配置类/启动类加**@ConfigurationProperties(prefix = "")**，并加入为属性，引用时用**@Autowired**

##### 环境隔离

- nacos中可以有多个namespace，来实现环境隔离

- namespace下可以有group、service等

  > Namespace > group"集群" > service
  >
  > 微服务 --- namespace，group --- （dev/test/prod）

  ```yml
  spring:
    application:
      name: gulimall-coupon ## 服务名称
    profiles:
      active: dev #开发环境，这里是dev 
    cloud:
      nacos:
        server-addr: localhost:8848 ## Nacos地址
        config:
          file-extension: yaml ## 文件后缀名
          namespace: b356927a-7b42-4610-a1aa-e92bd9c591e3 ## 命名空间
          group: dev ## 组名  
        
  ```

##### 最终配置

- bootstrap.properties

  ```properties
  ## 服务名称
  spring.application.name=gulimall-coupon
  #开发环境，这里是dev
  spring.profiles.active=dev
  ## Nacos地址
  spring.cloud.nacos.server-addr=192.168.10.103:8848
  ## 文件后缀名
  spring.cloud.nacos.config.file-extension=yml
  ## 命名空间
  spring.cloud.nacos.config.namespace=b356927a-7b42-4610-a1aa-e92bd9c591e3
  ## 组名
  spring.cloud.nacos.config.group=dev
  
  spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml
  spring.cloud.nacos.config.ext-config[0].group=dev
  spring.cloud.nacos.config.ext-config[0].refresh=true
  
  spring.cloud.nacos.config.ext-config[1].data-id=mybatis.yml
  spring.cloud.nacos.config.ext-config[1].group=dev
  spring.cloud.nacos.config.ext-config[1].refresh=true
  
  spring.cloud.nacos.config.ext-config[2].data-id=other.yml
  spring.cloud.nacos.config.ext-config[2].group=dev
  spring.cloud.nacos.config.ext-config[2].refresh=true
  ```

- nacos中的datasource.yml

  ```yml
  spring:
    datasource:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://42.193.100.99/gulimall_sms?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
      username: root
      password: root
  ```

- nacos中的mybatis.yml

  ```yml
  ## MapperScan
  ## sql映射文件位置
  mybatis-plus:
    mapper-locations: classpath:/mapper/**/*.xml
    global-config:
      db-config:
        id-type: auto
  ```

- nacos中的other.yml

  ```yml
  spring:
    application:
      name: gulimall-coupon
    cloud:
      nacos:
        discovery:
          server-addr: 192.168.10.103:8848
  server:
    port: 8000
  ```

#### openfeign

SpringCloud

以coupon与member服务为例，会员服务调用优惠券服务

- **依赖 --- openfeign** --- 谁需要远程服务谁添加

- coupon中的controller提供查询

  ```java
  @RequestMapping("coupon/coupon")
  public class CouponController {
      @Autowired
      private CouponService couponService;
  
      @RequestMapping("/member/list")
      public R membercoupons(){    //全系统的所有返回都返回R
          // 查数据库，但是没数据，伪造一个
          CouponEntity couponEntity = new CouponEntity();
          couponEntity.setCouponName("满100减10");//优惠券的名字
          return R.ok().put("coupons",Arrays.asList(couponEntity));
      }
    	
    	//...
  }
  ```

- member中编写接口，告诉SpringCloud需要调用远程服务

  - 怎么告诉？调用哪个远程服务？

    > @FeignClient("gulimall-coupon")

  - 调用哪个请求？

    > **请求地址全路径**，声明接口的每个方法调用哪个请求

  ```java
  @FeignClient("gulimall-coupon")
  public interface CouponFeignService {
  	@RequestMapping("/coupon/coupon/member/list")
  	public R membercoupons();
  }
  ```

- **开启远程调用 --- @EnableFeignClients**(basePackages="feign的包名")

- 在member的contriller中测试

  ```java
  @RestController
  @RequestMapping("member/member")
  public class MemberController {
      @Autowired
      private MemberService memberService;
  
      @Autowired
      CouponFeignService couponFeignService;
  
      @RequestMapping("/coupons")
      public R test(){
          MemberEntity memberEntity = new MemberEntity();
          memberEntity.setNickname("张三");
          R membercoupons = couponFeignService.membercoupons(); //假设张三去数据库查了后返回了张三的优惠券信息
  
          // 打印会员和优惠券信息
          return R.ok().put("member",memberEntity).put("coupons",membercoupons.get("coupons"));
      }
    //....
  }
  ```

  ```
  http://localhost:9000/member/member/coupons
  ```

#### Gateway

- 创建模块gulimall-gateway --- 添加gateway

- 依赖common

- 注册到nacos

- 启动类排除数据源 -- 因为有数据库的依赖，不排除会报错

  ```java
  @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
  @EnableDiscoveryClient
  public class GulimallGatewayApplication {
  
      public static void main(String[] args) {
          SpringApplication.run(GulimallGatewayApplication.class, args);
      }
  
  }
  ```

- bootstrap.yml

  ```yml
  spring:
    profiles:
      active: dev
    application:
      name: gulimall-gateway
  
    cloud:
      nacos:
        discovery:
          server-addr: 192.168.10.103:8848
        config:
          server-addr: 192.168.10.103:8848
          namespace: 9a220048-fb5b-4edd-99cb-71d76fb976ef
          group: dev
          file-extension: yml
  ```

- nacos中的guilmall-gateway-dev.yml

  ```yml
  spring:
    cloud:
      gateway:
        routes:
          - id: baidu_route
            uri: https://www.baidu.com
            predicates:
              - Query=url,baidu
  ##            - Path=/bai_du/**
  
          - id: qq_route
            uri: https://www.qq.com
            predicates:
  ##            - Query=url,qq
              - Path=/qq_/**
  server:
    port: 9999
  ```

- 测试

  ```
  测试 localhost:9999?url=baidu 	## 跳到百度页面
  测试 localhost:9999/qq_ 				## 跳到qq页面
  ```

#### Vue.js

*   安装node.js
*   安装vue
    ```sh
    npm i -g vue
    npm install -g @vue/cli
    npm install -g webpack
    ```
- 创建项目
  
    - 命令行`vue init webpack 项目名`
    - 图形化`vue ui`
    
- vue模板
  
    - 首选项 -- 用户片段 -- 全局片段 -- vue
    
        ```json
        {
        	"生成vue模板": {
        		"prefix": "vue",
        		"body": [
        			"<template>",
        			"<div></div>",
        			"</template>",
        			"",
        			"<script>",
        			"//这里可以导入其他文件（比如：组件，工具js，第三方插件js，json文件，图片文件等等）",
        			"//例如：import 《组件名称》 from '《组件路径》'",
        			"",
        			"export default {",
        			"//import引入的组件需要注入到对象中才能使用",
        			"components: {},",
        			"props: {},",
        			"data() {",
        			"//这里存放数据",
        			"return {};",
        			"},",
        			"//计算属性 类似于data概念",
        			"computed: {},",
        			"//监控data中的数据变化",
        			"watch: {},",
        			"//方法集合",
        			"methods: {},",
        			"//声明周期 - 创建完成（可以访问当前this实例）",
        			"created() {},",
        			"//声明周期 - 挂载完成（可以访问DOM元素）",
        			"mounted() {},",
        			"beforeCreate() {}, //生命周期 - 创建之前",
        			"beforeMount() {}, //生命周期 - 挂载之前",
        			"beforeUpdate() {}, //生命周期 - 更新之前",
        			"updated() {}, //生命周期 - 更新之后",
        			"beforeDestroy() {}, //生命周期 - 销毁之前",
        			"destroyed() {}, //生命周期 - 销毁完成",
        			"activated() {} //如果页面有keep-alive缓存功能，这个函数会触发",
        			"};",
        			"</script>",
        			"<style scoped>",
        			"</style>",
        		]
        	}
        }
        ```

#### 补充

##### 跨域问题

[跨源资源共享（CORS） - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)

- 跨域问题：`协议、IP（包括子级域名）、端口`不同都会造成跨域
- 同源策略：是指协议，域名，端囗都要相同，其中有一个不同都会产生跨域
- 跨源资源共享（CORS）
- 跨域流程
  - 非简单请求（PUT、DELETE等，不是简单请求的都是非简单请求）
    - 先使用OPTIONS发送预检请求
    - 响应允许跨域
    - 发送真实请求
    - 响应数据
  - 简单请求（GET、POST、HEAD），不发送预检请求，但是需要满足以下条件
    - 除了被用户代理自动设置的首部字段（例如 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection)，[`User-Agent`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent)）和在 Fetch 规范中定义为 [禁用首部名称](https://fetch.spec.whatwg.org/#forbidden-header-name) 的其他首部，允许人为设置的字段为 Fetch 规范定义的 [对 CORS 安全的首部字段集合](https://fetch.spec.whatwg.org/#cors-safelisted-request-header)。该集合为：[`Accept`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept)、[`Accept-Language`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language)、[`Content-Language`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language)、[`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)
    - Content-Type需要注意额外的限制`text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`
    - 请求中的任意 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 对象均没有注册任何事件监听器；[`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 对象可以使用 [`XMLHttpRequest.upload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload) 属性访问
    - 请求中没有使用 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream) 对象
- 解决方案
  - 通过Nginx部署为同一个域
  - 设置响应头，让服务器告诉预检请求能跨域

##### 逻辑删除

[逻辑删除 | MyBatis-Plus (baomidou.com)](https://baomidou.com/pages/6b03c5/#步骤-1-配置com-baomidou-mybatisplus-core-config-globalconfig-dbconfig)

- 配置文件

  - **有注解可以不配**

  ```yml
  mybatis-plus:
    global-config:
      db-config:
        logic-delete-field: flag ## 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
        logic-delete-value: 1 ## 逻辑已删除值(默认为 1)
        logic-not-delete-value: 0 ## 逻辑未删除值(默认为 0)
  
  ```

- 注解：实体类字段上加上`@TableLogic`注解

  - **全局配置的字段相同可以不加注解**

  - 若与全局配置的逻辑删除值相反，配置@TableLogic的属性

    > @TableLogic(value="1",delval="0")

  ```java
  @TableLogic
  private Integer deleted;
  ```

##### sql日志打印

```yml
logging:
  level:
  	包名: debug
```

##### 端口占用

```sh
lsof -i: 端口  #查进程
kill 进程
```

##### vue代码片段

```json
{
	"生成vue模板": {
		"prefix": "vue",
		"body": [
			"<template>",
			"<div></div>",
			"</template>",
			"",
			"<script>",
			"//这里可以导入其他文件（比如：组件，工具js，第三方插件js，json文件，图片文件等等）",
			"//例如：import 《组件名称》 from '《组件路径》'",
			"",
			"export default {",
			"//import引入的组件需要注入到对象中才能使用",
			"components: {},",
			"props: {},",
			"data() {",
			"//这里存放数据",
			"return {};",
			"},",
			"//计算属性 类似于data概念",
			"computed: {},",
			"//监控data中的数据变化",
			"watch: {},",
			"//方法集合",
			"methods: {},",
			"//声明周期 - 创建完成（可以访问当前this实例）",
			"created() {},",
			"//声明周期 - 挂载完成（可以访问DOM元素）",
			"mounted() {},",
			"beforeCreate() {}, //生命周期 - 创建之前",
			"beforeMount() {}, //生命周期 - 挂载之前",
			"beforeUpdate() {}, //生命周期 - 更新之前",
			"updated() {}, //生命周期 - 更新之后",
			"beforeDestroy() {}, //生命周期 - 销毁之前",
			"destroyed() {}, //生命周期 - 销毁完成",
			"activated() {} //如果页面有keep-alive缓存功能，这个函数会触发",
			"};",
			"</script>",
			"<style scoped>",
			"</style>",
		]
	},
	
	"http-get请求": {
        "prefix": "httpget",
        "body":[
            "this.\\$http({",
            "url: this.\\$http.adornUrl(''),",
            "method:'get',",
            "params:this.\\$http.adornParams({})",
            "}).then(({data})=>{",
            "});"
        ],
        "description":"httpGET请求"
    },

    "http-post请求":{
        "prefix":"httppost",
        "body":[
            "this.\\$http({",
            "url:this.\\$http.adornUrl(''),",
            "method:'post',",
            "data: this.\\$http.adornData(data, false)",
            "}).then(({data})=>{ });"
        ],
        "description":"httpPOST请求"
    }

}
```



### 商品服务

#### 三级分类

- 数据库创建表pms_category

##### 显示分类

###### 后端实现

- 查出所有分类以及子分类，以树形结构组装起来

  - CategoryEntity实体类添加一个属性，用于过滤子类

    ```java
    @TableField(exist = false)
    private List<CategoryEntity> children;
    ```

  - CategoryController

    ```java
    /**
     * 查询所有分类，并以树形展示
     */
    @RequestMapping("/list/tree")
    public R list(@RequestParam Map<String, Object> params){
        List<CategoryEntity> categoryEntities =  categoryService.listWithTree();
        return R.ok().put("date", categoryEntities);
    }
    ```

  - CategoryServiceImpl

    ```java
    @Override
    public List<CategoryEntity> listWithTree() {
    	//查所有分类
    	List<CategoryEntity> categoryEntities = baseMapper.selectList(null);
    	//树化
    	//1. 找一级分类parent_cid都是0
    	List<CategoryEntity> level1Menus = categoryEntities.stream().filter(categoryEntity -> {
    		return categoryEntity.getParentCid().longValue() == 0;
    		//2. 查子菜单
    	}).map(currentMenu -> {
    		currentMenu.setChildren(getChildrens(currentMenu,categoryEntities));
    		return currentMenu;
    		//3. 排序
    	}).sorted((menu1,menu2)->{
    		return (menu1.getSort() == null?0:menu1.getSort()) - (menu2.getSort() == null?0:menu2.getSort());
    	}).collect(Collectors.toList());
    	return categoryEntities;
    }
    
    /**
     * 递归查找所有菜单的子菜单
     * @param current 当前菜单
     * @param all  所有菜单
     * @return
     */
    private List<CategoryEntity> getChildrens(CategoryEntity current, List<CategoryEntity> all) {
    	// 1 找到子菜单
    	List<CategoryEntity> children = all.stream().filter(categoryEntity -> {
    		return categoryEntity.getParentCid().longValue() == current.getCatId().longValue();  // 注意此处应该用longValue()来比较，否则会出先bug，因为parentCid和catId是long类型
    	}).map(currentMenu -> {
    		currentMenu.setChildren(getChildrens(currentMenu, all));
    		return currentMenu;
    	}).sorted((menu1, menu2) -> {
    		// 2 菜单的排序
    		return (menu1.getSort() == null?0:menu1.getSort()) - (menu2.getSort() == null?0:menu2.getSort());
    	}).collect(Collectors.toList());
    	return children;
    }
    ```

###### 搭建分类管理系统

- 启动renren-fast和renren-fast-vue，接着操作后台

  ```
  系统管理，菜单管理，新增
  	- 目录
  	- 商品系统
  	- 一级菜单
  	- editor
  
  系统管理，菜单管理，继续新增：
  	- 菜单
  	- 分类维护
  	- 商品系统
  	- product/category  //配置网关路由
  	- menu
  ```

- 观察

  - 分类维护：路由设置的是product/category
  - 但是在地址栏变成了http://localhost:8001/#/product-category

- 再观察

  - 角色管理http://localhost:8001/#/sys-role
  - 对应renren-fast-vue中的src/views/mudules/sys/role.vue

- 故

  - product/category视图，就是创建mudules/product/category.vue

###### 前端实现 

- category.vue引入element-ui  [组件 | Element](https://element.eleme.cn/#/zh-CN/component/tree)

  ```vue
  <template>
    <el-tree :data="data" :props="defaultProps" @node-click="handleNodeClick"></el-tree>
  </template>
  
  <script>
  
  export default {
    data() {
     // 官网复制，此处略
    },
    //方法集合
    methods: {
      handleNodeClick(data) {
        console.log(data);
      },
    },
  };
  </script>
  <style scoped>
  </style>
  ```

- 后端获取data，参考其他，如role.vue

  ```vue
  <template>
    //...
    <el-button @click="getDataList()">查询</el-button>
    //...
  </template>
  
  <script>
  export default {
      //...
  		methods: {
        // 获取数据列表
        getDataList () {
          this.dataListLoading = true
          this.$http({
            url: this.$http.adornUrl('/sys/role/list'),
            method: 'get',
            params: this.$http.adornParams({
              'page': this.pageIndex,
              'limit': this.pageSize,
              'roleName': this.dataForm.roleName
            })
          }).then(({data}) => {
            if (data && data.code === 0) {
              this.dataList = data.page.list
              this.totalPage = data.page.totalCount
            } else {
              this.dataList = []
              this.totalPage = 0
            }
            this.dataListLoading = false
          })
        },
        //...
      }
  };
  </script>
  <style scoped>
  </style>
  ```

- 获取数据并测试

  ```vue
  <template>
    <el-tree
      :data="data"
      :props="defaultProps"
      @node-click="handleNodeClick"
    ></el-tree>
  </template>
  
  <script>
  export default {
    methods: {
      handleNodeClick(data) {
        console.log(data);
      },
      getMenus() {
        this.$http({
          url: this.$http.adornUrl("/product/category/list/tree"),
          method: "get",
        }).then(({ data }) => {
          console.log("chenggong",data)
        });
      },
    },
    activated() {
      this.getMenus()
    }, 
  };
  </script>
  <style scoped>
  </style>
  ```

  - 测试问题
    - 请求 URL: http://localhost:8080/renren-fast/product/category/list/tree
    - 应该为：12000端口（gulimall-product对应的端口）

###### 路径重写

- Ctrl+Shift+F全局搜索 `http://localhost:8080/renren-fast`

- 在static/config/index.js里，api接口请求地址全部交给网关转发

  ```js
  /**
   * 开发环境
   */
  ;(function () {
    window.SITE_CONFIG = {};
  
    // api接口请求地址
    window.SITE_CONFIG['baseUrl'] = 'http://localhost:9999/api';
  
    // cdn地址 = 域名 + 版本号
    window.SITE_CONFIG['domain']  = './'; // 域名
    window.SITE_CONFIG['version'] = '';   // 版本号(年月日时分)
    window.SITE_CONFIG['cdnUrl']  = window.SITE_CONFIG.domain + window.SITE_CONFIG.version;
  })();
  ```

- 测试问题

  - 重新登录，且验证码直接向网管发送请求 http://localhost:9999/captcha.jpg?uuid=d872db4d-5582-44bb-8a4b-baf96532f8d5

- 网关转发到renren-fast

  - 要想转发，需要先将renren-fast注册到nacos

    - 引入common依赖

    - 加注解

    - 配置文件application.yml --- 服务名，注册中心地址

    - 报错：依赖冲突

      [Spring Cloud](https://spring.io/projects/spring-cloud#overview)     

      [Maven Repository: com.alibaba.cloud » spring-cloud-starter-alibaba-nacos-discovery (mvnrepository.com)](https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery)

      | Release Train                                                | Boot Version                          |
      | :----------------------------------------------------------- | :------------------------------------ |
      | [2021.0.x](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes) aka Jubilee | 2.6.x, 2.7.x (Starting with 2021.0.3) |

      ```xml
      <dependency>
      	<groupId>com.alibaba.cloud</groupId>
      	<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
      	<version>2021.0.1.0</version>
      </dependency>
      ```

  - 在nacos中gulimall-gateway-dev.yml

    ```yml
    spring:
      cloud:
        gateway:
          routes:
            - id: renren_fast_route
              uri: lb://renren-fast  ## lb广播，广播到***服务集群的任意一个服务
              predicates:
                - Path=/api/**	     ## api下的任意路径，与static/config/index.js对应
    server:
      port: 9999
    ```

    - 测试发现还是不行
      - 从http://localhost:9999/api/captcha.jpg转到了http://renren-fast:8080/api/captcha.jpg
      - 实际需要http://localhost:8080/renren-fast/captcha.jpg即api换成服务名

  - 改gulimall-gateway-dev.yml

    [Spring Cloud Gateway](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-rewritepath-gatewayfilter-factory)

    ```yml
    spring:
      cloud:
        gateway:
          routes:
            - id: renren_fast_route
              uri: lb://renren-fast
              predicates:
                - Path=/api/**
              filters:
                - RewritePath=/api/?(?<segment>.*), /renren-fast/$\{segment}
    server:
      port: 9999
    ```

    - 测试发现验证码出来了，但无法登录
      - 跨域问题：`协议、IP（包括子级域名）、端口`不同都会造成跨域
      - 解决方法：在网关中定义“GulimallCorsConfiguration”类，该类用来做过滤，允许所有的请求跨域

###### 后端 -- 跨域类

- 在网关中定义“GulimallCorsConfiguration”类

```java
@Configuration
public class GulimallCorsConfiguration {

    @Bean
    public CorsWebFilter corsWebFilter(){
        // 基于url跨域，选择reactive包下的
        UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource();
      
        // 跨域配置信息
        CorsConfiguration corsConfiguration = new CorsConfiguration();
      
        // 1 允许跨域的头
        corsConfiguration.addAllowedHeader("*");
        // 2 允许跨域的请求方式
        corsConfiguration.addAllowedMethod("*");
        // 3 允许跨域的请求来源
        corsConfiguration.addAllowedOrigin("*");
        // 4 是否允许携带cookie跨域
        corsConfiguration.setAllowCredentials(true);
        
       	// 任意url都要进行跨域配置
        source.registerCorsConfiguration("/**",corsConfiguration);
        return new CorsWebFilter(source);
    }
}
```

- 测试发现，预检请求通过，真实请求报错：请求头有重复值

  ```
  Access to XMLHttpRequest at 'http://localhost:9999/api/sys/login' from origin 'http://localhost:8001' has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header contains multiple values 'http://localhost:8001, http://localhost:8001', but only one is allowed.
  ```

  - 修改renren-fast项目，注释掉“io.renren.config.CorsConfig”类 -- 也配置了跨域

- 测试发现，登录成功，但是`分类维护`报错

  - 请求 URL: http://localhost:9999/api/product/category/list/tree

  - 需要的地址没有`api`，`端口号`是gulimall-product的

  - 编写网关，将所有与商品有关的转发到商品服务

    ```yml
    spring:
      cloud:
        gateway:
          routes:
            - id: renren_fast_route
              uri: lb://renren-fast
              predicates:
                - Path=/api/**
              filters:
                - RewritePath=/api/?(?<segment>.*), /renren-fast/$\{segment}
                
            - id: product_route
              uri: lb://gulimall-product
              predicates:
                - Path=/api/product/**
              filters:
                - RewritePath=/api/?(?<segment>.*), /$\{segment}
    server:
      port: 9999
    ```

- 测试发现，还是不行`{"msg":"invalid token","code":401}`

  - 调整两个路由规则的顺序

    ```yml
    spring:
      cloud:
        gateway:
          routes:
            - id: product_route
              uri: lb://gulimall-product
              predicates:
                - Path=/api/product/**
              filters:
                - RewritePath=/api/?(?<segment>.*), /$\{segment}
                
            - id: renren_fast_route
              uri: lb://renren-fast
              predicates:
                - Path=/api/**
              filters:
                - RewritePath=/api/?(?<segment>.*), /renren-fast/$\{segment}
    server:
      port: 9999
    ```

###### 数据绑定

```vue
<template>
  <el-tree
    :data="menus"
    :props="defaultProps"
    @node-click="handleNodeClick"
  ></el-tree>
</template>

<script>
export default {
  data() {
    return {
      menus: [],
      defaultProps: {
        children: "children", //描述子节点的属性值
        label: "name", //节点显示的属性值
      },
    };
  },
  methods: {
    handleNodeClick(data) {
      console.log(data);
    },
    getMenus() {
      this.$http({
        url: this.$http.adornUrl("/product/category/list/tree"),	//异步调用
        method: "get",
      }).then(({ data }) => {	//解构出data
        this.menus = data.data;	//第二个data为后端返回的key
        console.log("成功返回", data.data);
      });
    },
  },
  activated() {
    this.getMenus();
  },
};
</script>
<style scoped>
</style>
```

###### 总结

- 后端编写查询，封装为tree
- 搭建分类管理 --- 注意路由设置规则
- 模仿着写前端获取查询结果的方法
- 测试发现，路径问题，重写路径，统一经过网关转发
- 测试发现，验证码也向网关发送请求，配置网关的路由，转发给renren-fast
- 测试发现，跨域问题，编写跨域类，设置请求头
- 测试发现，分类管理列表向网关发送请求，配置网关路由，转发给gulimall-product
- 数据绑定，解构出数据，进行动态绑定

##### 增删改分类

###### 前端观察

- category.vue引入element-ui  [组件 | Element](https://element.eleme.cn/#/zh-CN/component/tree)

  - 引入增加和删除组件`<span>`
    - node为当前节点对象
    - data为当前节点数据
  - 增加append方法、remove方法
    - 先打印node，data进行观察
  - 按钮优化
    - 三级节点不能再增加：观察node有个level属性表示层级，故`v-if="node.level <= 2"`
    - 有子节点的不能删除：观察node有个childNodes属性，是子节点的数组，故`v-if="node.childNodes.length==0"`

  ```vue
  <template>
    <el-tree
      :data="menus"
      :props="defaultProps"
      show-checkbox
      node-key="catId"
      default-expand-all
      :expand-on-click-node="false"
      >>
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)"
          >
            Append
          </el-button>
          <el-button
            v-if="node.childNodes.length==0"
            type="text"
            size="mini"
            @click="() => remove(node, data)"
          >
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>
  </template>
  
  <script>
  export default {
    data() {
      return {
        menus: [],
        defaultProps: {
          children: "children", //描述子节点的属性值
          label: "name", //节点显示的属性值
        },
      };
    },
    methods: {
      handleNodeClick(data) {
        console.log(data);
      },
      getMenus() {
        this.$http({
          url: this.$http.adornUrl("/product/category/list/tree"), //异步调用
          method: "get",
        }).then(({ data }) => {
          //解构出data
          this.menus = data.data; //第二个data为后端返回的key
          console.log("成功返回", data.data);
        });
      },
      append(data) {
        console.log("添加", data);
      },
  
      remove(node, data) {
        console.log("删除", node, data);
      },
    },
    activated() {
      this.getMenus();
    },
  };
  </script>
  <style scoped>
  </style>
  ```

###### 后端实现

- 删除
  - 要保证被引用了不能删除
  - 不能物理删除，用一个字段表示显示状态，进行逻辑删除

- controller

  ```java
  @RequestMapping("/delete")
  public R delete(@RequestBody Long[] catIds){
      categoryService.removeMenusByIds(Arrays.asList(catIds));
      return R.ok();
  }
  ```

- service

  ```java
  @Override
  public void removeMenusByIds(List<Long> asList) {
  	// todo 引用的不能删除
  	// 逻辑删除
  	baseMapper.deleteBatchIds(asList);
  }
  ```

###### 前端实现

- 参考其他，如role.vue的post请求

  ```js
  this.$http({
    url: this.$http.adornUrl("/sys/role/delete"),
    method: "post",
    data: this.$http.adornData(ids, false),
  }).then(({ data }) => {});
  ```

- 引入element -ui

  - [对话框组件](https://element.eleme.cn/#/zh-CN/component/dialog)：用于添加、修改
  - [弹窗组件](https://element.eleme.cn/#/zh-CN/component/message-box)：用于删前提示 

  - [消息提示组件](https://element.eleme.cn/#/zh-CN/component/message)：用于操作成功、取消的提示
  - 注意，更新时回显，要重新查表
  - 注意，后端返回数据的key统一为data

  ```html
  <template>
    <div>
      <el-tree
        :data="menus"
        :props="defaultProps"
        show-checkbox
        node-key="catId"
        :default-expanded-keys="expandedKey"
        :expand-on-click-node="false"
      >
        <span class="custom-tree-node" slot-scope="{ node, data }">
          <span>{{ node.label }}</span>
          <span>
            <el-button
              v-if="node.level <= 2"
              type="text"
              size="mini"
              @click="() => append(data)"
            >
              增加
            </el-button>
            <el-button type="text" size="mini" @click="() => update(data)">
              修改
            </el-button>
            <el-button
              v-if="node.childNodes.length == 0"
              type="text"
              size="mini"
              @click="() => remove(node, data)"
            >
              删除
            </el-button>
          </span>
        </span>
      </el-tree>
  
      <!-- 添加菜单对话框 -->
      <el-dialog
        :title="title"
        :visible.sync="dialogVisible"
        width="30%"
        :close-on-click-modal="false"
      >
        <!-- 表单 -->
        <el-form :model="category">
          <el-form-item label="分类名称">
            <el-input v-model="category.name" autocomplete="off"></el-input>
          </el-form-item>
          <el-form-item label="图标">
            <el-input v-model="category.icon" autocomplete="off"></el-input>
          </el-form-item>
          <el-form-item label="计量单位">
            <el-input
              v-model="category.productUnit"
              autocomplete="off"
            ></el-input>
          </el-form-item>
        </el-form>
  
        <span slot="footer" class="dialog-footer">
          <el-button @click="dialogVisible = false">取 消</el-button>
          <el-button type="primary" @click="submitData"
            >确 定</el-button
          >
        </span>
      </el-dialog>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {
        title: "",  //复用的对话框，名称动态绑定
        category: { //category对象，并初始化
          name: "",
          parentCid: 0,
          catLevel: 0,
          showStatus: 1,
          sort: 0,
          catId: null,
          icon: "",
          productUnit: "",
        },
        dialogType: "", //复用的对话框
        menus: [],      //树状菜单
        expandedKey: [],//展开的节点
        dialogVisible: false, //控制对话框显示
        defaultProps: {
          children: "children", //描述子节点的属性值
          label: "name", //节点显示的属性值
        },
      };
    },
    methods: {
      handleNodeClick(data) {
        console.log(data);
      },
      // 获取树状分类菜单
      getMenus() {
        this.$http({
          url: this.$http.adornUrl("/product/category/list/tree"),
          method: "get",
        }).then(({ data }) => { //解构出data
          this.menus = data.data; //第二个data为后端返回的key
          console.log("成功返回", data.data);
        });
      },
      // 触发增加
      append(data) {
        this.dialogType = "add";  //使弹出的是增加对话框
        this.title = "添加分类";    //动态绑定对话框title
        this.dialogVisible = true;  //弹出对话框
        console.log("添加", data);
        // 还原为默认值
        this.category.name = "";
        this.category.icon = "";
        this.category.productUnit = "";
        this.category.catId = null;
        this.category.parentCid = data.catId;
        this.category.catLevel = data.catLevel + 1;
      },
      // 触发修改
      update(data) {
        this.dialogType = "edit";   //使弹出的是修改对话框
        this.title = "修改分类";     //动态绑定对话框title
        this.dialogVisible = true;  //弹出对话框
  
        // 发送请求，获取最新节点数据
        this.$http({
          url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
          method: "get",
        }).then(({ data }) => {
          console.log("回显",data);
          // 用于回显、封装数据
          this.category.name = data.data.name;
          this.category.catId = data.data.catId;
          this.category.icon = data.data.icon;
          this.category.productUnit = data.data.productUnit;
          // 用于展开
          this.category.parentCid = data.data.parentCid;
        });
      },
      // 提交表单数据
      submitData() {
        if (this.dialogType == "add") {
          this.addCategory();
        } else if (this.dialogType == "edit") {
          this.editCategory();
        }
      },
      // 修改菜单
      editCategory() {
        console.log("获取菜单数据", this.category);
        // 解构
        var { catId, icon, productUnit, name } = this.category;
        this.$http({
          url: this.$http.adornUrl("/product/category/update"),
          method: "post",
          //kv相同，简写封装请求参数
          data: this.$http.adornData({ catId, icon, productUnit, name }, false),
        }).then(({ data }) => {
          // 消息提示
          this.$message({
            type: "success",
            message: "菜单修改成功!",
          });
          // 关闭对话框
          this.dialogVisible = false;
          // 刷新
          this.getMenus();
          // 显示节点
          this.expandedKey = [this.category.parentCid];
        });
      },
      // 增加菜单
      addCategory() {
        console.log("获取菜单数据", this.category);
        this.$http({
          url: this.$http.adornUrl("/product/category/save"),
          method: "post",
          data: this.$http.adornData(this.category, false),
        }).then(({ data }) => {
          // 消息提示
          this.$message({
            type: "success",
            message: "菜单删除成功!",
          });
          // 关闭对话框
          this.dialogVisible = false;
          // 刷新
          this.getMenus();
          // 显示节点
          this.expandedKey = [this.category.parentCid];
        });
      },
      // 删除菜单
      remove(node, data) {
        console.log("删除", node, data);
        //获取ids
        var ids = [data.catId];
        // 弹窗，确认删除
        this.$confirm(`删除【${data.name}】菜单, 是否继续?`, "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning",
        })
          .then(() => {
            //确认删除，发送请求
            this.$http({
              url: this.$http.adornUrl("/product/category/delete"),
              method: "post",
              data: this.$http.adornData(ids, false),
            }).then(({ data }) => {
              // 刷新
              this.getMenus();
              // 消息提示
              this.$message({
                type: "success",
                message: "菜单删除成功!",
              });
              // 显示节点
              this.expandedKey = [node.parent.data.catId];
            });
          })
          .catch(() => {
            // 取消删除，消息提示
            this.$message({
              type: "info",
              message: "已取消删除",
            });
          });
      },
    },
    activated() {
      this.getMenus();
    },
  };
  </script>
  <style scoped>
  </style>
  ```

##### 拖拽分类

###### 前端实现

```vue
<template>
  <div>
    <el-switch
      v-model="draggable"
      active-text="开启拖拽"
      inactive-text="关闭拖拽"
    >
    </el-switch>
    <el-button @click="batchSave" v-if="draggable">批量保存</el-button>
    <el-tree
      :data="menus"
      :props="defaultProps"
      show-checkbox
      node-key="catId"
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false"
      :draggable="draggable"
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
    >
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)"
          >
            增加
          </el-button>
          <el-button type="text" size="mini" @click="() => update(data)">
            修改
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)"
          >
            删除
          </el-button>
        </span>
      </span>
    </el-tree>

    <!-- 添加菜单对话框 -->
    <el-dialog
      :title="title"
      :visible.sync="dialogVisible"
      width="30%"
      :close-on-click-modal="false"
    >
      <!-- 表单 -->
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input
            v-model="category.productUnit"
            autocomplete="off"
          ></el-input>
        </el-form-item>
      </el-form>

      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="submitData">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
export default {
  data() {
    return {
      pCid: [], //拖拽节点父节点id
      draggable: false, //是否可拖拽
      updateNodes: [], //所有要更新到数据库的节点
      maxLevel: 0,
      title: "", //复用的对话框，名称动态绑定
      category: {
        //category对象，并初始化
        name: "",
        parentCid: 0,
        catLevel: 0,
        showStatus: 1,
        sort: 0,
        catId: null,
        icon: "",
        productUnit: "",
      },
      dialogType: "", //复用的对话框
      menus: [], //树状菜单
      expandedKey: [], //展开的节点
      dialogVisible: false, //控制对话框显示
      defaultProps: {
        children: "children", //描述子节点的属性值
        label: "name", //节点显示的属性值
      },
    };
  },
  methods: {
    handleNodeClick(data) {
      console.log(data);
    },
    // 批量保存
    batchSave() {
      this.$http({
        url: this.$http.adornUrl("/product/category/update/sort"),
        method: "post",
        data: this.$http.adornData(this.updateNodes, false),
      })
        .then(({ data }) => {
          this.$message({
            type: "success",
            message: "菜单顺序修改成功!",
          });
          // 刷新出新的菜单
          this.getMenus();
          // 设置需要默认展开的菜单，否则拖动过程中越来越多
          this.expandedKey = this.pCid;
          this.updateNodes = [];
          this.maxLevel = 0;
          // this.pCid = 0;
        })
        .catch(() => {});
    },
    // 监听拖拽
    handleDrop(draggingNode, dropNode, dropType, ev) {
      console.log("tree drop: ", draggingNode, dropNode.label, dropType);
      //1 当前节点最新的父节点
      let pCid = 0;
      let siblings = null;
      if (dropType == "before" || dropType == "after") {
        pCid =
          dropNode.parent.data.catId == undefined
            ? 0
            : dropNode.parent.data.catId;
        siblings = dropNode.parent.childNodes;
      } else {
        pCid = dropNode.data.catId;
        siblings = dropNode.childNodes;
      }
      this.pCid.push(pCid);
      //2 当前拖拽节点的最新顺序
      for (let i = 0; i < siblings.length; i++) {
        if (siblings[i].data.catId == draggingNode.data.catId) {
          // 如果遍历的是当前正在拖拽的节点
          let catLevel = draggingNode.level;
          if (siblings[i].level != draggingNode.level) {
            // 当前节点的层级发生变化
            catLevel = siblings[i].level;
            // 修改他子节点的层级
            this.updateChildNodeLevlel(siblings[i]);
          }
          this.updateNodes.push({
            catId: siblings[i].data.catId,
            sort: i,
            parentCid: pCid,
            catLevel: catLevel,
          });
        } else {
          this.updateNodes.push({ catId: siblings[i].data.catId, sort: i });
        }
      }
      //3 当前拖拽节点的最新层级
      console.log("updateNodes", this.updateNodes);
    },
    // 更新子节点层级
    updateChildNodeLevlel(node) {
      if (node.childNodes.length > 0) {
        for (let i = 0; i < node.childNodes.length; i++) {
          var cNode = node.childNodes[i].data;
          this.updateNodes.push({
            catId: cNode.catId,
            catLevel: node.childNodes[i].level,
          });
          this.updateChildNodeLevlel(node.childNodes[i]);
        }
      }
    },
    /**
     * 拖拽时判定目标节点能否被放置
     * @param draggingNode 拖拽的节点
     * @param dropNode 放置的目标节点
     * @param type 'prev'、'inner' 和 'next'，拖到目标节点前、目标节点内、目标节点后
     */
    allowDrop(draggingNode, dropNode, type) {
      console.log("能否被放置", draggingNode, dropNode, type);
      //被拖动节点有的层数 + 放置的父节点层级 <= 3
      this.countNodeLevel(draggingNode);
      let deep = Math.abs(this.maxLevel - draggingNode.level) + 1; //被拖动节点有的层数
      if (type == "inner") {
        return deep + dropNode.level <= 3;
      } else {
        return deep + dropNode.parent.level <= 3;
      }
    },
    // 统计拖拽节点的最大层数
    countNodeLevel(node) {
      //找到所有子节点，求最大深度
      if (node.childNodes != null && node.childNodes.length > 0) {
        for (let i = 0; i < node.childNodes.length; i++) {
          if (node.childNodes[i].level > this.maxLevel) {
            this.maxLevel = node.childNodes[i].level; //大于maxLevel就赋给maxLevel
          }
          this.countNodeLevel(node.childNodes[i]); //递归，子节点遍历
        }
      }
    },
    // 获取树状分类菜单
    getMenus() {
      this.$http({
        url: this.$http.adornUrl("/product/category/list/tree"),
        method: "get",
      }).then(({ data }) => {
        //解构出data
        this.menus = data.data; //第二个data为后端返回的key
        console.log("成功返回", data.data);
      });
    },
    // 触发增加
    append(data) {
      this.dialogType = "add"; //使弹出的是增加对话框
      this.title = "添加分类"; //动态绑定对话框title
      this.dialogVisible = true; //弹出对话框
      console.log("添加", data);
      // 还原为默认值
      this.category.name = "";
      this.category.icon = "";
      this.category.productUnit = "";
      this.category.catId = null;
      this.category.parentCid = data.catId;
      this.category.catLevel = data.catLevel * 1 + 1; // * 1，防止是字符串
    },
    // 触发修改
    update(data) {
      this.dialogType = "edit"; //使弹出的是修改对话框
      this.title = "修改分类"; //动态绑定对话框title
      this.dialogVisible = true; //弹出对话框

      // 发送请求，获取最新节点数据
      this.$http({
        url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
        method: "get",
      }).then(({ data }) => {
        console.log("回显", data);
        // 用于回显、封装数据
        this.category.name = data.data.name;
        this.category.catId = data.data.catId;
        this.category.icon = data.data.icon;
        this.category.productUnit = data.data.productUnit;
        // 用于展开
        this.category.parentCid = data.data.parentCid;
      });
    },
    // 提交表单数据
    submitData() {
      if (this.dialogType == "add") {
        this.addCategory();
      } else if (this.dialogType == "edit") {
        this.editCategory();
      }
    },
    // 修改菜单
    editCategory() {
      console.log("获取菜单数据", this.category);
      // 解构
      var { catId, icon, productUnit, name } = this.category;
      this.$http({
        url: this.$http.adornUrl("/product/category/update"),
        method: "post",
        //kv相同，简写封装请求参数
        data: this.$http.adornData({ catId, icon, productUnit, name }, false),
      }).then(({ data }) => {
        // 消息提示
        this.$message({
          type: "success",
          message: "菜单修改成功!",
        });
        // 关闭对话框
        this.dialogVisible = false;
        // 刷新
        this.getMenus();
        // 显示节点
        this.expandedKey = [this.category.parentCid];
      });
    },
    // 增加菜单
    addCategory() {
      console.log("获取菜单数据", this.category);
      this.$http({
        url: this.$http.adornUrl("/product/category/save"),
        method: "post",
        data: this.$http.adornData(this.category, false),
      }).then(({ data }) => {
        // 消息提示
        this.$message({
          type: "success",
          message: "菜单删除成功!",
        });
        // 关闭对话框
        this.dialogVisible = false;
        // 刷新
        this.getMenus();
        // 显示节点
        this.expandedKey = [this.category.parentCid];
      });
    },
    // 删除菜单
    remove(node, data) {
      console.log("删除", node, data);
      //获取ids
      var ids = [data.catId];
      // 弹窗，确认删除
      this.$confirm(`删除【${data.name}】菜单, 是否继续?`, "提示", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
        type: "warning",
      })
        .then(() => {
          //确认删除，发送请求
          this.$http({
            url: this.$http.adornUrl("/product/category/delete"),
            method: "post",
            data: this.$http.adornData(ids, false),
          }).then(({ data }) => {
            // 刷新
            this.getMenus();
            // 消息提示
            this.$message({
              type: "success",
              message: "菜单删除成功!",
            });
            // 显示节点
            this.expandedKey = [node.parent.data.catId];
          });
        })
        .catch(() => {
          // 取消删除，消息提示
          this.$message({
            type: "info",
            message: "已取消删除",
          });
        });
    },
  },
  activated() {
    this.getMenus();
  },
};
</script>
<style scoped>
</style>
```

###### 后端实现

```java
@RequestMapping("/update/sort")
public R updateSort(@RequestBody CategoryEntity[] category){
		categoryService.updateBatchById(Arrays.asList(category));

    return R.ok();
}
```

##### 批量删除

```vue
<template>
  <div>
    <el-switch
      v-model="draggable"
      active-text="开启拖拽"
      inactive-text="关闭拖拽"
    >
    </el-switch>
    <el-button @click="batchSave" v-if="draggable">批量保存</el-button>
    <el-button type="danger" @click="batchDelete">批量删除</el-button>
    <el-tree
      :data="menus"
      :props="defaultProps"
      show-checkbox
      node-key="catId"
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false"
      :draggable="draggable"
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
      ref="menuTree"
    >
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)"
          >
            增加
          </el-button>
          <el-button type="text" size="mini" @click="() => update(data)">
            修改
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)"
          >
            删除
          </el-button>
        </span>
      </span>
    </el-tree>

    <!-- 添加菜单对话框 -->
    <el-dialog
      :title="title"
      :visible.sync="dialogVisible"
      width="30%"
      :close-on-click-modal="false"
    >
      <!-- 表单 -->
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input
            v-model="category.productUnit"
            autocomplete="off"
          ></el-input>
        </el-form-item>
      </el-form>

      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="submitData">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
export default {
  data() {
    return {
      pCid: [], //拖拽节点父节点id
      draggable: false, //是否可拖拽
      updateNodes: [], //所有要更新到数据库的节点
      maxLevel: 0,
      title: "", //复用的对话框，名称动态绑定
      category: {
        //category对象，并初始化
        name: "",
        parentCid: 0,
        catLevel: 0,
        showStatus: 1,
        sort: 0,
        catId: null,
        icon: "",
        productUnit: "",
      },
      dialogType: "", //复用的对话框
      menus: [], //树状菜单
      expandedKey: [], //展开的节点
      dialogVisible: false, //控制对话框显示
      defaultProps: {
        children: "children", //描述子节点的属性值
        label: "name", //节点显示的属性值
      },
    };
  },
  methods: {
    handleNodeClick(data) {
      console.log(data);
    },
     // 批量删除
    batchDelete() {
      let catIds = [];
      let checkedNodes = this.$refs.menuTree.getCheckedNodes();
      console.log("被选中的元素", checkedNodes);
      for (let i = 0; i < checkedNodes.length; i++) {
        catIds.push(checkedNodes[i].catId);
      }

      this.$confirm(`是否批量删除【${catIds}】菜单?`, "提示", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
        type: "warning",
      })
        .then(() => {
          this.$http({
            url: this.$http.adornUrl("/product/category/delete"),
            method: "post",
            data: this.$http.adornData(catIds, false),
          })
            .then(({ data }) => {
              this.$message({
                type: "success",
                message: "菜单批量删除成功!",
              });
              // 刷新出新的菜单
              this.getMenus();
            })
            .catch(() => {});
        })
        .catch(() => {});
    },
    // 批量保存
    batchSave() {
      this.$http({
        url: this.$http.adornUrl("/product/category/update/sort"),
        method: "post",
        data: this.$http.adornData(this.updateNodes, false),
      })
        .then(({ data }) => {
          this.$message({
            type: "success",
            message: "菜单顺序修改成功!",
          });
          // 刷新出新的菜单
          this.getMenus();
          // 设置需要默认展开的菜单，否则拖动过程中越来越多
          this.expandedKey = this.pCid;
          this.updateNodes = [];
          this.maxLevel = 0;
          // this.pCid = 0;
        })
        .catch(() => {});
    },
    // 监听拖拽
    handleDrop(draggingNode, dropNode, dropType, ev) {
      console.log("tree drop: ", draggingNode, dropNode.label, dropType);
      //1 当前节点最新的父节点
      let pCid = 0;
      let siblings = null;
      if (dropType == "before" || dropType == "after") {
        pCid =
          dropNode.parent.data.catId == undefined
            ? 0
            : dropNode.parent.data.catId;
        siblings = dropNode.parent.childNodes;
      } else {
        pCid = dropNode.data.catId;
        siblings = dropNode.childNodes;
      }
      this.pCid.push(pCid);
      //2 当前拖拽节点的最新顺序
      for (let i = 0; i < siblings.length; i++) {
        if (siblings[i].data.catId == draggingNode.data.catId) {
          // 如果遍历的是当前正在拖拽的节点
          let catLevel = draggingNode.level;
          if (siblings[i].level != draggingNode.level) {
            // 当前节点的层级发生变化
            catLevel = siblings[i].level;
            // 修改他子节点的层级
            this.updateChildNodeLevlel(siblings[i]);
          }
          this.updateNodes.push({
            catId: siblings[i].data.catId,
            sort: i,
            parentCid: pCid,
            catLevel: catLevel,
          });
        } else {
          this.updateNodes.push({ catId: siblings[i].data.catId, sort: i });
        }
      }
      //3 当前拖拽节点的最新层级
      console.log("updateNodes", this.updateNodes);
    },
    // 更新子节点层级
    updateChildNodeLevlel(node) {
      if (node.childNodes.length > 0) {
        for (let i = 0; i < node.childNodes.length; i++) {
          var cNode = node.childNodes[i].data;
          this.updateNodes.push({
            catId: cNode.catId,
            catLevel: node.childNodes[i].level,
          });
          this.updateChildNodeLevlel(node.childNodes[i]);
        }
      }
    },
    /**
     * 拖拽时判定目标节点能否被放置
     * @param draggingNode 拖拽的节点
     * @param dropNode 放置的目标节点
     * @param type 'prev'、'inner' 和 'next'，拖到目标节点前、目标节点内、目标节点后
     */
    allowDrop(draggingNode, dropNode, type) {
      console.log("能否被放置", draggingNode, dropNode, type);
      //被拖动节点有的层数 + 放置的父节点层级 <= 3
      this.countNodeLevel(draggingNode);
      let deep = Math.abs(this.maxLevel - draggingNode.level) + 1; //被拖动节点有的层数
      if (type == "inner") {
        return deep + dropNode.level <= 3;
      } else {
        return deep + dropNode.parent.level <= 3;
      }
    },
    // 统计拖拽节点的最大层数
    countNodeLevel(node) {
      //找到所有子节点，求最大深度
      if (node.childNodes != null && node.childNodes.length > 0) {
        for (let i = 0; i < node.childNodes.length; i++) {
          if (node.childNodes[i].level > this.maxLevel) {
            this.maxLevel = node.childNodes[i].level; //大于maxLevel就赋给maxLevel
          }
          this.countNodeLevel(node.childNodes[i]); //递归，子节点遍历
        }
      }
    },
    // 获取树状分类菜单
    getMenus() {
      this.$http({
        url: this.$http.adornUrl("/product/category/list/tree"),
        method: "get",
      }).then(({ data }) => {
        //解构出data
        this.menus = data.data; //第二个data为后端返回的key
        console.log("成功返回", data.data);
      });
    },
    // 触发增加
    append(data) {
      this.dialogType = "add"; //使弹出的是增加对话框
      this.title = "添加分类"; //动态绑定对话框title
      this.dialogVisible = true; //弹出对话框
      console.log("添加", data);
      // 还原为默认值
      this.category.name = "";
      this.category.icon = "";
      this.category.productUnit = "";
      this.category.catId = null;
      this.category.parentCid = data.catId;
      this.category.catLevel = data.catLevel * 1 + 1; // * 1，防止是字符串
    },
    // 触发修改
    update(data) {
      this.dialogType = "edit"; //使弹出的是修改对话框
      this.title = "修改分类"; //动态绑定对话框title
      this.dialogVisible = true; //弹出对话框

      // 发送请求，获取最新节点数据
      this.$http({
        url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
        method: "get",
      }).then(({ data }) => {
        console.log("回显", data);
        // 用于回显、封装数据
        this.category.name = data.data.name;
        this.category.catId = data.data.catId;
        this.category.icon = data.data.icon;
        this.category.productUnit = data.data.productUnit;
        // 用于展开
        this.category.parentCid = data.data.parentCid;
      });
    },
    // 提交表单数据
    submitData() {
      if (this.dialogType == "add") {
        this.addCategory();
      } else if (this.dialogType == "edit") {
        this.editCategory();
      }
    },
    // 修改菜单
    editCategory() {
      console.log("获取菜单数据", this.category);
      // 解构
      var { catId, icon, productUnit, name } = this.category;
      this.$http({
        url: this.$http.adornUrl("/product/category/update"),
        method: "post",
        //kv相同，简写封装请求参数
        data: this.$http.adornData({ catId, icon, productUnit, name }, false),
      }).then(({ data }) => {
        // 消息提示
        this.$message({
          type: "success",
          message: "菜单修改成功!",
        });
        // 关闭对话框
        this.dialogVisible = false;
        // 刷新
        this.getMenus();
        // 显示节点
        this.expandedKey = [this.category.parentCid];
      });
    },
    // 增加菜单
    addCategory() {
      console.log("获取菜单数据", this.category);
      this.$http({
        url: this.$http.adornUrl("/product/category/save"),
        method: "post",
        data: this.$http.adornData(this.category, false),
      }).then(({ data }) => {
        // 消息提示
        this.$message({
          type: "success",
          message: "菜单删除成功!",
        });
        // 关闭对话框
        this.dialogVisible = false;
        // 刷新
        this.getMenus();
        // 显示节点
        this.expandedKey = [this.category.parentCid];
      });
    },
    // 删除菜单
    remove(node, data) {
      console.log("删除", node, data);
      //获取ids
      var ids = [data.catId];
      // 弹窗，确认删除
      this.$confirm(`删除【${data.name}】菜单, 是否继续?`, "提示", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
        type: "warning",
      })
        .then(() => {
          //确认删除，发送请求
          this.$http({
            url: this.$http.adornUrl("/product/category/delete"),
            method: "post",
            data: this.$http.adornData(ids, false),
          }).then(({ data }) => {
            // 刷新
            this.getMenus();
            // 消息提示
            this.$message({
              type: "success",
              message: "菜单删除成功!",
            });
            // 显示节点
            this.expandedKey = [node.parent.data.catId];
          });
        })
        .catch(() => {
          // 取消删除，消息提示
          this.$message({
            type: "info",
            message: "已取消删除",
          });
        });
    },
  },
  activated() {
    this.getMenus();
  },
};
</script>
<style scoped>
</style>
```

#### 品牌管理



















