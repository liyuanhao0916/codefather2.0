# 计算机组成原理

## 概述

### 早期冯诺依曼机

- 计算机硬件系统由运算器、存储器、控制器、输入设备、输出设备
- 指令和数据以同等地位存储在存储器中，并可按地址寻访
- 指令和数据均以二进制代码表示
- 指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址
- 指令在存储器内按顺序存放
- 早期的冯诺依曼以运算器为中心，输入输出设备通过运算器与存储器传输数据

> 存储程序：将指令以代码的形式先输入到计算机的主存储器中，然后按按照存储器的首地址开始，按规定顺序执行指令

> 数据通过输入设备将信号转换为机器可以识别的二进制数据，
>
> 通过运算器中转存到存储器
>
> 通过运算器计算，再通过输出设备，将二进制转化为人类语言
>
> 控制器协调输入设备、输出设备、运算器、存储器

### 现代计算机

微处理器问世之前，运算器和控制器是分离的，而且存储器容量很小，因此以运算器为中心

随着微电子技术的进步，计算机需要处理加工的信息量与日俱增，大量的IO设备速到与CPU的速度差距悬殊，不能以运算器为中心

现在计算机以存储器为中心，使IO操作尽可能绕过CPU，直接在IO设备和存储器之间完成

现代CPU一般包含两部分，运算器和控制器

### 组成

硬件

- 主机

  - CPU

    - 运算器：用于实现算数运算、逻辑运算
      - ACC：累加器，用于存放操作数、运算结果
      - MQ：乘商寄存器，寄存乘除运算的操作数和运算结果
      - X：通用的操作数寄存器
      - ALU：算术逻辑单元，通过内部复杂的电路实现算数运算和逻辑运算
    - 控制器：指挥中心，协调作用
      - 取指令--程序计数器（PC）：存放将要执行的指令地址，执行后自动+1，与MAR直接连通
      - 分析指令--指令寄存器（IR）：存放当前的指令，指令内容来自主存的MDR，指令中的操作码送给CU
      - 执行指令--控制单元（CU）：分析IR中发来的指令码，发出各种微操作命令序列；IR发来的地址码送往MDR取操作数

  - 存储器：

    - 主存（内存）
      - CPU可以直接访问主存，辅存必须写入主存后才能被CPU访问
      - 主存是按存储单元的地址进行存取
      - 存储体：存储二进制数据，按地址存储
        - 每个地址对应一个存储单元，存储单元是由存储字组成
        - 存储字：二进制代码组合，这串代码就是存储字
        - 存储字长：存储单元中二进制代码的位数
        - 存储元件：每个存储元件存储0或1，可以存储1bit，是根据电容设计的
      - 地址寄存器（MAR）：存放地址，MAR的位数反映存储单元的个数，如MAR=4，则总共有2^4个存储单元，MAR的长度与PC的长度相等
      - 数据寄存器（MDR）：暂存读写的数据，MDR位数 = 存储字长
      - 虽然MAR、MDR属于存储器，但是现代的设计都是在CPU中

    - 辅存（外存、硬盘） --- 一般归为IO设备

- 外设
  - 输入设备
  - 输出设备

### 程序运行

```c
int a=2,b=3,c=1,y=0;
void main(){
    y = a*b+c;
}
```

```
主存地址			指令（操作码|地址码）		注释
	0			000001	0000000101		取数a到ACC
	1			000100	0000000110		乘b得ab，存于ACC
	2			000011	0000000111		加c的ab+c，存于ACC
	3			000010	0000001000		将ab+c存于主存存储单元
	4			000110	0000000000		停机
	5			0000000000000010		a=2
	6			0000000000000011		b=3
	7			0000000000000001		c=1
	8			0000000000000000		y=0
```



每条指令都需要经过取出指令、分析指令、执行指令三个步骤

- 取出指令经过：控制器的程序计数器（PC）、主存的地址寄存器（MAD）、主存的存储体、主存的数据寄存器（MDR）、控制器的指令寄存器（IR）
- 分析指令经过：控制器的指令寄存器（IR）、控制器的控制单元（CU）
- 执行命令经过：控制器的控制单元（CU）、取数、运算器

第一条指令：

- #0:(PC)= 0，初始时，指向第一条指令的存储地址

- #1:(PC)->MAR，在MAR中读取第一条指令的地址，(MAR) = 0
- #3:M(MAR)->MDR，在存储体中拿到地址为0的数据传给MDR，MDR=000001	0000000101
- #4:(MDR)->IR，指令寄存器IR = 000001	0000000101
- #5:OP(IR)->CU，将IR中的操作码送到CU，CU分析得知是取数指令
- #6:Ad(IR)->MAR，将IR中的地址码送到MAR，拿到数据的地址，(MAR) = 5
- #8:M(MAR)->MDR，在存储体中拿出地址为5的数据传给MDR，MDR=0000000000000010
- #9:(MDR)->ACC，CU指导将MDR传给ACC

第二条指令：

- #0:第一条指令执行后，PC自动+1，(PC)=1，ACC = 2

- #1:(PC)->MAR，在MAR中读取第二条指令的地址，(MAR) = 1
- #3:M(MAR)->MDR，在存储体中取出地址为1的数据传给MDR，MDR = 000010	0000001000
- #4:(MDR)->IR，传给IR = 000010	0000001000
- #5:OP(IR)->CU，将IR的操作码从到CU，CU分析得知是乘法指令
- #6:Ad(IR)->MAR，将IR中的地址码送到MAR，拿到数据的地址，(MAR) = 6
- #8:M(MAR)->MDR，在存储体中拿出地址为5的数据传给MDR，MDR=0000000000000011
- #9:(MDR)->MQ，将MDR传到乘商寄存器，MQ=0000000000000011
- #10:(ACC)->X，将ACC中的2传到通用寄存器，X = 2
- #11:(MQ)*(X)->ACC，将计算结果传到ACC，ACC=6，如果乘积过大，需要MQ辅助存储

第三条指令

- #0:第一条指令执行后，PC自动+1，(PC)=2，ACC = 6
- #1:(PC)->MAR，在MAR中读取第二条指令的地址，(MAR) = 2
- #3:M(MAR)->MDR，在存储体中取出地址为1的数据传给MDR，MDR = 000011	0000000111
- #4:(MDR)->IR，传给IR = 000011	0000000111
- #5:OP(IR)->CU，将IR的操作码从到CU，CU分析得知是加法指令
- #6:Ad(IR)->MAR，将IR中的地址码送到MAR，拿到数据的地址，(MAR) = 7
- #8:M(MAR)->MDR，在存储体中拿出地址为5的数据传给MDR，MDR=0000000000000001
- #9:(MDR)->X，将MDR传到乘商寄存器，X=0000000000000001
- #10:(ACC)+(X)->ACC，将计算结果传到ACC，ACC=7，由ALU实现加法运算

第四条指令

- #0:第一条指令执行后，PC自动+1，(PC)=3，ACC = 7
- #1:(PC)->MAR，在MAR中读取第二条指令的地址，(MAR) = 3
- #3:M(MAR)->MDR，在存储体中取出地址为1的数据传给MDR，MDR = 000011	0000000111
- #4:(MDR)->IR，传给IR = 000011	0000000111
- #5:OP(IR)->CU，将IR的操作码从到CU，CU分析得知是存数指令
- #6:Ad(IR)->MAR，将IR中的地址码送到MAR，拿到数据的地址，(MAR) = 8
- #7:(ACC)->MDR，将数据存入地址为8的MDR
- #9:(MDR)->使得 y对应的值为 7

第五条指令

- #0:第一条指令执行后，PC自动+1，(PC)=4
- #1:(PC)->MAR，在MAR中读取第二条指令的地址，(MAR) = 4
- #3:M(MAR)->MDR，在存储体中取出地址为1的数据传给MDR，MDR = 000110	0000000000
- #4:(MDR)->IR，传给IR = 000110	0000000000
- #5:OP(IR)->CU，将IR的操作码从到CU，CU分析得知是停机指令

### 三个级别-五层结构

- M4：高级语言机器 --- 执行高级语言
- M3：汇编语言机器 --- 执行汇编语言
- M2：操作系统机器 --- 向上提供广义命令
- M1：传统机器 --- 执行机器语言，二进制
- M0：微程序机器 --- 执行微指令

### 性能指标

MAR位数：存储单元的个数

MDR位数：存储字长，每个存储单元的大小

总容量 = MAR位数 * MDR位数 （bit）/ 8  = (MAR位数 * MDR位数 / 8)(Byte)

CPU主频：CPU内数字脉冲信号振荡的频率，单位Hz

CPU时钟周期与主频互为倒数

CPI：执行一条指令所需要的时钟周期数

- 不同的指令CPI不一定相同
- 不同的CPU，执行相同的指令，CPI也不一定相同

执行一条指令耗时：CPU的时钟周期 * CPI

CPU执行时间（程序执行耗时） = CPU时钟周期数 / 主频 = （指令数 * CPI）/ 主频

IPS：每秒执行多少指令 = 主频 / 评价CPI

FLOPS：每秒执行多少次浮点运算

> IPS、FLOPS前常加单位K、M、G、T、P、E、Z，如KIPS、MFLOPS；换位为1000，G就是十亿

数据通路带宽：数据总线一次并行传送信息的位数（各个硬件部件都是通过数据总线传输数据）

吞吐量：系统单位时间内处理请求的数量，取决于主存的存取周期

响应时间：一个请求作出响应所需要的时间：CPU时间+等待时间（磁盘访问、存储器访问、IO、操作系统开销）

> 主频高一定快吗？
>
> 不一定，A的主频2GHz，评价CPI=10，B主频1GHz，平均CPI=1，A每秒只能处理0.2G的指令，B每秒能处理1G条指令
>
> 若CPI相同，那主频高一定快吗？
>
> 不一定，还要看A支不支持一些指令，如乘法指令，若不支持只能多次加法，而B支持乘法指令，那B就更快
>
> 基准程序执行越快性能越好吗？
>
> 不一定，基准程序中的语句存在频度差异，运行结果不能完全说明问题

### 概念解析

**翻译程序、汇编程序、编译程序、解释程序**

翻译程序：把高级语言翻译成机器语言，分为编译程序、解释程序

汇编程序：把汇编程序翻译成机器语言，汇编语言与机器语言一一对应，只是有助记符号

**机器字长、指令字长、存储字长**

机器字长：机器能直接处理的二进制位数，一般机器字长等于内存的大小，决定了运算精度

指令字长：一个指令包含的二进制位数

存储字长：一个存储单元存储的二进制的长度 = MDR位数

他们都是字节的整数倍，指令字长一般是存储字长的整数倍，若指令字长是存储字长的2倍，则需要访问两次取出一条指令

## 数据表示与运算

### 数制与编码

#### 进位计数法

**基数**：每个数位所用到的不同数码的个数。如十进制的基数为10

**位权**：对应位置上需要乘的数值

**公式**：
$$
N = a[k] * r^k + a[k-1] * r^(k-1) + ... + a[2] * r^2 + a[1] * r^1 + a[0] * r^0
$$

- r是基数，k是对应的位置，a[k]是对应位置的值，`r^k`是位权

#### 进制转换

**二转八**：三位截断一算

**二转十六**：四位截断一算

**N转十**：用公式

**十转N**

- 整数部分：除基取余，上低下高
- 小数部分：乘基取整

> 在计算机中，整数可以连续表示，但是小数是离散的，故并不是所有的十进制小数都可以用二进制表示，比如0.3无论多少次乘2取整都无法得到精确的结果。但是二进制小数都可转十进制小数

#### 真值、机器数

真值：是机器数代表的实际值

机器数：计算机中用0，1表示正负号，采用原码、补码、反码表示正负数，这种把符号数字化的数称为机器数

#### BCD码

BCD码：二进制编码的十进制数（BCD）通常采用4位二进制数表示一位十进制数中0-9这10个数码，使得两者之间的转换能快速进行，但是4位可以表示16个数码，存在6种的冗余状态

- 8421码（最常用）：是一种有权码，权值为8421，若两个8421码相加，小于等于9则无需修正，大于等于10则需要修正，因为有6位无效码，所以需要将结果+6（+0110），即需要向高位进位
- 余3码：是一种无权码，在8421码上+3（+0011）形成的，因为每个数都多余3，故称余3
- 2421码：是有权码，权值为2421，特点是--大于等于5的4位二进制数最高位为1，小于5的最高位为0，如5（1011）

#### ASCII码

ASCII码：是一种字符系统，7位二进制编码，每个字节的最高位保持为0，可用于传输时的积偶校验位，可以表示128个字符

- 0-31为控制字符，用于通信控制或设备的功能控制
- 127为DEL码
- 32为空格
- 32-126为可印刷字符
- 0-9的ASCII码为48（011 0000） - 57（011 1001）去掉高三位正好为0-9

#### 校验码

校验码：能够发现或能够自动纠错的数据编码，也叫检错纠错码，原理是通过增加一些冗余码

- 码距：任意两个合法码字之间最少变化的二进制位数，如1100和1101只有一位变化了，码距为1,1001和0010码距为3

- 码距不小于2的校验码，具有检错能力，码距越大，检错纠错能力越强，而且检错能力总是大于纠错能力

- 奇偶校验码：加一位作为校验码，码距为2，可以测出一位错误（或奇数位错误），但不能确定错误的位置，也不能监测出偶数为错误；奇偶校验码是由有效信息位+1个奇偶校验位组成，校验位的取值（0或1）是整个校验码中1的个数为奇数或偶数

  - 奇校验码：整个校验码（有效信息位+校验位）中1的个数为奇数，则校验位为0，否则为1，保证校验码中1的个数为奇数
  - 偶校验码：整个校验码（有效信息位+校验位）中1的个数为偶数，则校验位为0，否则为1，保证校验码中1的个数为偶数
  - 如1001101，设最高位1位校验码，余7位位信息位，1有4个为偶数，故校验位为1，奇校验码为1 1001101，偶校验码为 0 1001101，再如1010111，1有5个为奇数，故校验位为0，奇校验码为0 1010111，偶校验码为1 1010111
  - 具有局限性，只能发现奇数个位出错（有1个3个5个...位置反转了，就和校验位对不上了），还不能纠错，常用语对存储器数据的检查或数据传输的检查

- 海明校验码：实际是一种多重奇偶校验码，将海明码的每个二进制位分配到几个奇偶校验组中，当某一位出错，就会引起关联的几个检验位发生变化，可以找到错误位置，为纠错提供依据

  - 纠错理论
    $$
    L-1 = D+C     且    D≥C
    $$

  - 编码的最小码距L越大，其检测错误的位数D越大，纠正错误的位数C也越大，且纠错能力恒小于等于检错能力

  - 如n=4，k=3，求1010的海明码

    - 确定位数，n为有效信息的位数，k为校验位的位数，n+k=7<=2^3-1成立，则满足海明码校验要求
    
    - 有效位D4D3D2D1（1010），校验位P3P2P1，最终的海明码H7H6H5H4H3H2H1
    
    - 计算校验位插入位置
      $$
      \ P_k 对应 H_{2^{k-1}}
      $$
      
    
      - P3对应 2^2=4即H4
    
      - P2对应 2^1=2即H2
    
      - P1对应 2^0=1即H1
    
      - 即H7H6H5H4H3H2H1对应D4 D3 D2 P3 D1 P2 P1
        $$
        H_7\,H_6\,H_5\,H_4\,H_3\,H_2\,H_1 \\
        
        D_4\;D_3\; D_2\; P_3\; D_1\; P_2\; P_1
        $$
    
    - 校验条件：被校验数据的海明位号等于校验各海明位号的和
    
      - D1在H3上，所以3 = 1 + 2，即由P1和P2校验
      - D2在H5上，所以5 = 1 + 4，即由P1和P3校验
      - D3在H6上，所以6 = 2 + 4，即由P2和P3校验
      - D4在H7上，所以7 = 1 + 2 + 4，即由P1、P2、P3校验
    
    - 校验位取值：Pi的值为所有需要Pi校验的位求异或
    
      - P1 = D1 ^ D2 ^ D4 = 0^1^1 = 0
      - P2 = D1 ^ D3 ^ D4 = 0^0^1 = 1
      - P3 = D2 ^ D3 ^ D4 = 1^0^1 = 0
      - 故对应的海明码为1010010
    
    - 校验原理：k个校验组利用校验位和形成该校验位的信息进行奇偶校验，形成k个校验方程
    
      - S1 = P1 ^ D1 ^ D2 ^ D4
      - S2 = P2 ^ D1 ^ D3 ^ D4
      - S3 = P3 ^ D2 ^ D3 ^ D4
      - 若S3S2S1 = 000，则无错，否则等于几就是第几位出错，如S3S2S1=001，则H1出错，按位取反即可

- 循环冗余校验码（CRC）：在K位信息码后拼接R位校验位，得到长度为N的校验码，故又称为（N,K）码

  - 基于线性编码理论，发送端，将传送的K位信息左移R位，低位用0补齐，将它与约定的多项式G(x)做模2除法，生成新的R位校验位，在接收端用同样的多项式做模2除法，能整除则无错
  - 任意一个二进制位都可以用系数为0或1的多项式与其对应，生成多项式的最高次幂为R，转换的二进制数有R+1位，直白说，多项式的系数就是对应的二进制数，有就是1，没有就是0，如x^3+x+1对应的就是1011
  - 如约定好的多项式为G(x)=x^3+x^2+1，信息码为101001
    - R=最高位次幂=3，K=6，N=9，多项式对应的二进制为1101
    - 移位后101001000
    - 模2除法产生余数001
    - CRC码为101001001
    - 接收端进行模2除法，余数为0，则无误
    - 若接收到了101001011，进行模2除法后余数010，则倒数第二位出错，取反即可

#### 模2运算

模2运算是一种二进制运算，CRC校验技术的核心，模2运算不考虑进位或借位，模2运算是编码理论中多项式运算的基础

**模2加法**：0+0 =0，1+0 =1 ，0+1 =1，1+1=0，可以把0看做偶数，1看做奇数，其实就是执行了异或运算

**模2减法**：0-0=0，1-1=0，1-0=1，0-1=1，和加法一模一样

**模2乘法**：和平时的乘法运算是一样的

**模2除法**：和平时的除法运算是一样的，有三个性质

- 当最后余数的位数小于除数位数时，除法停止
- 当被除数的位数小于除数位数（或最高位为0）时，则商数为0，被除数就是余数
- 只要被除数位数与除数一样多，且最高位为1，则商1

### 定点数表示与运算

无符号数：整个机器字长的全部二进制位均为数值，没有符号位

有符号数：通常约定二进制的最高位为符号位，有符号数的机器表示有原码、补码、反码、移码，约定用X表示真值，[X]原、[X]补、[X]反、[X]移，分别表示原码、补码、反码、移码

根据小数点的位置是否固定，分为定点表示、浮点表示

定点表示的小数点固定不变，不在使用小数点表示，而是约定它的位置，在计算机中一般两种约定

定点小数：最高位之前 ---- 定点小数

定点整数：最低位之后 ---- 定点整数

#### 定点小数

定点小数是纯小数，约定小数点位置在符号位之后，有效数值位最高位之前

- 若X=x0x1x2...xn（x0表示符号位，后面的是数值有效位，x1为最高有效位）

- 当x0为0，后面的都是1，X即所能表示的最大正数，真值等于1-2^(-n)
- 当x0为1，后面的都是1，X即（原码）所能表示的最小负数，真值等于-（1-2^(-n)）

#### 定点整数

定点整数是纯整数，约定小数点在有效数值位最低位之后

- 若X=x0x1x2...xn（x0表示符号位，后面的是数值有效位，xn为最低有效位）
- 当x0为0，后面的都是1，X即所能表示的最大正数，真值等于2^n-1
- 当x0为1，后面的都是1，X即（原码）所能表示的最小负数，真值等于-（2^n-1）

#### 原、补、反、移

> 原码表示看起来很美好，对人来说识别起来也很简单，并且对比如1+2=3这样的加法也正确，但是对负数就力不从心了。计算机中只有加法器，所有的减法都是把被减数转化为相反数再相加的。考虑5-3=2，5的原码是00000101，-3的原码是10000011，两个相加就是10001000，这是原码表示的-8，所以用原码进行直接加减是不行的
>
> **由钟表表盘得到的启发**
> 看看墙上的挂钟，表盘有从1到12的12个数字，指针从任意时刻转了一圈后又回到原来的位置。如果想把时针从1点拨到5点，那就有两种拨法：顺时针拨动4格，或者逆时针拨动8格。也就是说，顺时针拨动4格的效果和逆时针拨动8格的效果是相同的，若规定顺时针为正，逆时针为负，那就可以这样操作：1时-8时=1时+4时，即1-8=1+4，也就是说，-8可以用+4表示，或者说是等价的。回到上面我们算的5-3=2，用这个时钟系统能算对吗？-3时能用几时表示呢，对，是9时，则5-3就可以用5+9来计算，5+9=14，越过12时后停在2时，这不就是5-3=2的结果嘛！至此，我们就在钟表上用加法实现了减法，就像-3可以用+9来表示一样
>
> 计算机就是个二进制的模运算系统，之所以如此，是因为数据可以无限大，但计算机的表示能力是受硬件限制的，比如8位机，只能用8个二进制位表示一个整数，8位能组合出来的0-1状态只有 00000000~11111111这256个状态，255再加1也会回0。
>
> 给一个数，怎样算出它的补码？很简单，就一句话，**加上N个模让它变成模以内的一个正数**就可以了。比如-1的补码就是-1+256（8位机的模就是2^8）=255，255就是11111111；-100的补码就是-100+256=156，156的二进制序列10011100就是-100的补码。
>
> **为什么是取反加1，而不是加2加3？**
>
> 一个二进制序列各位取反后和自身相加是多少？不就是各个位全1嘛，再加1会发生什么，各位全变0，最高位进1舍去，其实就一个数和自己的相反数相加变0
>
>  **-1000的补码是多少（8位的情况）？**
> 按照我们上面加N个模的算法，-1000+4*256=24，也就是00011000。是不是有点不对劲啊，我们明明是个负数，怎么符号位是0啊？
>
> 这其实是-1000超出了8位机负数的取值范围而发生了溢出错误。
>
> 我们知道，8个二进制位能表示的组合只有00000000~11111111这256种，如果不考虑负数，那就是0~255，如果想表示负数，那就得把其中一半的位置让出来。从-1来看，根据补码计算方法，-1+256=255，也就是255这个二进制序列11111111来表示-1，同样，254就表示-2，253就表示-3……128就表示-128，二进制序列是10000000，再减1就变成了127，01111111，然后126，125……一直到0，这样循环一周-1……-128，127……0，所以8位二进制能表示的有符号数范围就是-128~127，之所以把10000000定为-128而不是+128，我的理解是符号位能统一起来。总结一下吧，补码本质就是一种用正数表示负数的模运算编码系统，它可以统一加减法，符号位也可以参与运算，并且让硬件电路简化，所以才被计算机的整数采用
>

**原码**：机器数的最高位表示符号位，剩下的表示数值位，0有+0和-0两种形式

- 纯小数

$$
[x]_原 = \begin{cases}  
x& 1>x≥0 \\
1-x = 1 + |x| & 0≥x>-1 \\
\end{cases}
([x]_原是原码机器数，x表示真值)
$$

​		若x1 = +0.1101，x2=-0.1101，字节长8位，则原码为[x1]原 = 0.1101000，[x2]原 = 1.1101000

- 纯整数

$$
[x]_原 = \begin{cases}  
0,x& 2^n>x≥0 \\
2^n-x = 2^n + |x| & 0≥x>-2^n \\
\end{cases}
([x]_原是原码机器数，x表示真值,n是整数位数,逗号是分割)
$$

​		若x1=+1110，x2=-1110，字节为8，则则原码为[x1]原 = 0,0001110，[x2]原 = 1,0001110

**反码**：负数的数值位按位取反，计算机用不到，只是作为中间状态，0有+0和-0两种形式

**补码**：负数的补码为反码 + 1，0的补码只有一种，范围比原码多一个（整数多一个-2^n，小数多一个-1）

- 原码和补码的简便转化，符号位之后，最后一个1之前，中间的按位取反
- 由[x]补求[-x]补，所有位取反，末尾+1

- 如[x]补=1 001 0011的原码为1 110 1101

- 整数如[x]补 = 1 000 0000表示-128，原码不能表示
- 小数如[x]补 = 1.000 0000表示-1，原码不能表示

**移码**：补码的符号位取反，移码只能表示整数，范围和整数的补码相同（-2^n ~ 2^n-1）

- 原码和移码的简便转化，最后一个1之前的位全部取反
- 如[x]移 = 1 001 0011的原码为0 110 1101
- 移码全0对应最小值-2^n，移码全1，对应2^n-1
- 移码保持了数据原有的大小顺序

#### 定点数的运算

**算数移位**

- 正数，空位补0
- 负数
  - 原码，空位补0
  - 补码，左移补0，右移添1
  - 反码，空位补1
- 原码，左移一位若不溢出，相当于乘2

**逻辑移位**

相当于正数的算数移位

**循环移位**

移出的数据又移入到数据中，适合用于数据低字节与高字节互换

**原码加减法**

加法：

- 符号相同，符号不变，绝对值相加
- 符号不同，做减法，绝对值大的减绝对值小的，符号位与绝对值大的相同

减法：减数符号取反，然后按加法运算

**补码加减法**

- 按二进制运算规则运算（逢二进一）
- 符号位与数值位按相同规则一起参与运算

**溢出判断**

- 一位符号位：运算结果的符号位与实际结果符号不同，则有溢出
- 双符号位：两符号位相同，则未溢出，高符号位为真正符号位
- 一位符号位与进位：符号位进位与最高数值位进位相同，则未溢出

**乘法计算**

乘法由累加和右移实现

- 原码一位乘法：符号和数值分开求
  - 符号位：两个乘数的符号位求异或
  - 数值位：两个乘数的数值位相乘，计算方式和十进制相同，乘数从最低位依次与被乘数相乘，结果相加

> 在机器中，
>
> - ACC累加器中存放部分积的高位，初始为0，
> - MQ中存放乘数和部分积右移后的低位，
> - X通用寄存器中存放被乘数

```
-- 设机器字长5位，含1位符号位，x=-0.1101，y=0.1011，采用原码一位乘法求xy

（高位 部分积 存储在ACC）			（低位部分积/乘数 存储在MQ乘商寄存器）
	00.0000							1011	初始时ACC全0，MQ存储乘数
  +	00.1101									从乘数最低位开始，即MQ的第四位，遇1将ACC+被乘数后右移一位
  ----------
  	00.1101	
  >	00.0110							1101|1	右移后MQ溢出的就舍去
  +	00.1101									依然取MQ的最低位，遇1将ACC+被乘数后右移一位
  ----------
  	01.0011							1101|1	加法需要考虑进位
  >	00.1001							1110|11
  + 00.0000									依然取MQ的最低位，遇0将直接右移一位
  > 00.0100							1111|011
  +	00.1101
  ----------
  	01.0001
  >	00.1000							1111|1011
  
  故数值位的结果为00.1000 1111
  符号位为负，异或得1，即最后乘积为-0.1000 1111
```

- 补码一位乘法
  - Booth算法：
    - 符号位参与运算，结果为补码
    - 被乘数x取双符号位参与运算，部分积取双符号位，初始为0，乘数y可取单符号位
    - 乘数末位增设附加位y，初始值为0
    - 根据